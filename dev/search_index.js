var documenterSearchIndex = {"docs":
[{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"EditURL = \"https://github.com/LCSB-BioCore/PikaParser.jl/blob/master/docs/src/scheme.jl\"","category":"page"},{"location":"scheme/#Example:-Parsing-Scheme","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"","category":"section"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"Here we prepare a small parser for a very simple Scheme-like language.","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"The main features of the parser include:","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"handling whitespace\nparsing number-containing identifiers and numbers while avoiding ambiguities using not_followed_by\nerror recovery by manually traversing the memo table","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"We choose not to implement any of the Scheme data types except numbers and identifiers; also all top-level expressions must be parenthesized \"command\" S-expressions.","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"import PikaParser as P\n\nrules = Dict(\n    :letter => P.satisfy(isletter),\n    :digit => P.satisfy(isdigit),\n    :ident => P.tie(\n        P.seq(\n            P.seq(:letter),\n            P.many(:inIdent => P.first(:letter, :digit, P.token('-'))),\n            P.not_followed_by(:inIdent),\n        ),\n    ),\n    :number => P.seq(P.some(:digit), P.not_followed_by(:inIdent)),\n    :ws => P.many(P.satisfy(isspace)),\n    :popen => P.seq(P.token('('), :ws),\n    :pclose => P.seq(P.token(')'), :ws),\n    :sexpr => P.seq(:popen, :insexpr => P.many(:scheme), :pclose),\n    :scheme => P.seq(:basic => P.first(:number, :ident, :sexpr), :ws),\n    :top => P.seq(:ws, :sexpr), #support leading blanks\n);\nnothing #hide","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"Notice that the rules \"clean\" the space characters after each sensible token is matched, except for :top that is able to clean up the leading spaces.  This way prevents unnecessary checking (and redundant matching) of the tokens, and buildup of uninteresting entries in the memo table.","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"Let's test the grammar on a piece of source code that contains lots of whitespace and some errors.","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"p = P.parse(P.make_grammar([:top], P.flatten(rules)), collect(\"\"\"\n(plus 1 2 3)\n(minus 1 2(plus 3 2)  ) woohoo extra parenthesis here )\n(complex\n  id3nt1f13r5)\n(invalid 1d3n7)\n(something\n  1\n  2\n  valid)\n(straight (out (missing(parenthesis error))\n(apply (make-function) (make-data))\n\"\"\"));\nnothing #hide","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"To traverse the input, we'll try to find the top matches. If the top match cannot be found, we will try to match at least something and report it. The memo table is conveniently ordered by match position.","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"top_matches =\n    [(key.pos, mid) for (key, mid) = p.memo if p.grammar.names[key.clause] == :top]","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"Prepare a folding function:","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"fold_scheme(r, m, s) =\n    r == :number ? parse(Int, String(P.view_match(p, m))) :\n    r == :ident ? Symbol(String(P.view_match(p, m))) :\n    r == :insexpr ? Expr(:call, :S, s...) :\n    r == :sexpr ? s[2] : r == :top ? s[2] : length(s) > 0 ? s[1] : nothing;\nnothing #hide","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"We can run through all top matches, tracking the position where we would expect the next match:","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"next_pos = 1\nfor (pos, mid) in top_matches\n    global next_pos\n    m = p.matches[mid]\n    if pos < next_pos # this match is a part of another that was already processed\n        continue\n    end\n    if pos > next_pos # something was not parsed!\n        @warn \"Could not parse input, skipping!\" unrecognized =\n            String(p.input[next_pos:m.pos-1])\n    end\n    value = P.traverse_match(p, mid, fold = fold_scheme)\n    @info \"Got a command\" value\n    next_pos = m.pos + m.len # skip behind the match\nend","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"We can see that the unparseable parts of input were correctly skipped, while the sensible parts were interpreted as expressions. The chosen error recovery method might not be optimal in the case of missing parentheses â€“ as an improvement, one might choose to utilize another grammar rule to find a good part of input to discard (e.g., everything to the end of the line).","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"","category":"page"},{"location":"scheme/","page":"Example: Parsing Scheme","title":"Example: Parsing Scheme","text":"This page was generated using Literate.jl.","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"EditURL = \"https://github.com/LCSB-BioCore/PikaParser.jl/blob/master/docs/src/json.jl\"","category":"page"},{"location":"json/#Example:-Parsing-JSON","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"","category":"section"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"Here we prepare a parser of a very small subset of JSON.","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"The main features of the parser include:","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"handling sequences with separators\nhandling string escapes\nbuilding native Julia data objects using a dictionary of handlers","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"The simplifications that we choose not to handle are the following:","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"we do not support whitespace between tokens\nfor obvious reasons, we do not consider full floating point number support\nthe escape sequences allowed in strings are rather incomplete","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"import PikaParser as P\n\nrules = Dict(\n    :t => P.tokens(collect(\"true\")),\n    :f => P.tokens(collect(\"false\")),\n    :null => P.tokens(collect(\"null\")),\n    :int => P.some(:digit),\n    :digit => P.satisfy(isdigit),\n    :quote => P.token('\"'),\n    :esc => P.token('\\\\'),\n    :string => P.seq(:quote, :instrings => P.many(:instring), :quote),\n    :instring => P.first(\n        :escaped => P.seq(:esc, P.first(:esc, :quote)),\n        :notescaped => P.satisfy(x -> x != '\"' && x != '\\\\'),\n    ),\n    :array => P.seq(P.token('['), P.first(:inarray, P.epsilon), P.token(']')),\n    :sep => P.token(','),\n    :inarray => P.tie(P.seq(P.seq(:json), P.many(:separray => P.seq(:sep, :json)))),\n    :obj => P.seq(P.token('{'), P.first(:inobj, P.epsilon), P.token('}')),\n    :pair => P.seq(:string, P.token(':'), :json),\n    :inobj => P.tie(P.seq(P.seq(:pair), P.many(:sepobj => P.seq(:sep, :pair)))),\n    :json => P.first(:obj, :array, :string, :int, :t, :f, :null),\n);\nnothing #hide","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"To manage the folding easily, we keep the fold functions in a data structure with the same order as rules:","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"folds = Dict(\n    :t => (i, m, s) -> true,\n    :f => (i, m, s) -> false,\n    :null => (i, m, s) -> nothing,\n    :int => (i, m, s) -> parse(Int, String(i[m.pos:m.pos+m.len-1])),\n    :quote => (i, m, s) -> i[m.pos],\n    :esc => (i, m, s) -> i[m.pos],\n    :escaped => (i, m, s) -> s[2],\n    :notescaped => (i, m, s) -> i[m.pos],\n    :string => (i, m, s) -> String(Char.(s[2])),\n    :instrings => (i, m, s) -> s,\n    :array => (i, m, s) -> isnothing(s[2]) ? [] : s[2],\n    :inarray => (i, m, s) -> s,\n    :separray => (i, m, s) -> s[2],\n    :obj => (i, m, s) -> isnothing(s[2]) ? Dict{String,Any}() : Dict{String,Any}(s[2]),\n    :pair => (i, m, s) -> (s[1] => s[3]),\n    :sepobj => (i, m, s) -> s[2],\n    :inobj => (i, m, s) -> s,\n)\n\ndefault_fold(i, match, subvals) = isempty(subvals) ? nothing : subvals[1]\n\ng = P.make_grammar([:json], P.flatten(rules));\nnothing #hide","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"Let's parse a simple JSONish string that demonstrates most of the rules:","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"input = collect(\n    \"\"\"{\"something\":123,\"other\":false,\"refs\":[1,2,[],{},true,false,null,[1,2,3,\"haha\"],{\"is\\\\\"Finished\\\\\"\":true}]}\"\"\",\n);\n\np = P.parse(g, input);\nnothing #hide","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"Let's build a Julia JSON-like structure:","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"result = P.traverse_match(\n    p,\n    P.find_match_at!(p, :json, 1),\n    fold = (r, m, s) -> get(folds, r, default_fold)(input, m, s),\n)","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"Detail:","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"result[\"refs\"]","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"","category":"page"},{"location":"json/","page":"Example: Parsing JSON","title":"Example: Parsing JSON","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Data-types","page":"Reference","title":"Data types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PikaParser]\nPages = [\"structs.jl\"]","category":"page"},{"location":"reference/#PikaParser.MatchResult","page":"Reference","title":"PikaParser.MatchResult","text":"A shortcut for possibly failed match result index (that points into ParserState field matches.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Clause","page":"Reference","title":"PikaParser.Clause","text":"abstract type Clause{G}\n\nAbstract type for all clauses that match a grammar with rule labels of type G.\n\nCurrently implemented clauses:\n\nSatisfy\nScan\nToken\nTokens\nEpsilon\nFail\nSeq\nFirst\nNotFollowedBy\nFollowedBy\nSome\nMany\nTie\n\nOften it is better to use convenience functions for rule construction, such as seq or token; see flatten for details.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Epsilon","page":"Reference","title":"PikaParser.Epsilon","text":"struct Epsilon{G} <: PikaParser.Clause{G}\n\nAn always-succeeding epsilon match.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Fail","page":"Reference","title":"PikaParser.Fail","text":"struct Fail{G} <: PikaParser.Clause{G}\n\nAn always-failing match.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.First","page":"Reference","title":"PikaParser.First","text":"struct First{G} <: PikaParser.Clause{G}\n\nMatch the first possibility of several matches. Empty First is equivalent to unconditional failure.\n\nFields\n\nchildren::Vector\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.FollowedBy","page":"Reference","title":"PikaParser.FollowedBy","text":"struct FollowedBy{G} <: PikaParser.Clause{G}\n\nZero-length match that succeeds if follow does match at the same position.\n\nFields\n\nfollow::Any\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Grammar","page":"Reference","title":"PikaParser.Grammar","text":"struct Grammar{G}\n\nA representation of the grammar prepared for parsing.\n\nFields\n\nnames::Vector\nTopologically sorted list of rule labels (non-terminals)\nidx::Dict{G, Int64} where G\nMapping of rule labels to their indexes in names\nclauses::Vector{PikaParser.Clause{Int64}}\nClauses of the grammar converted to integer labels (and again sorted topologically)\ncan_match_epsilon::Vector{Bool}\nFlags for the rules being able to match on empty string unconditionally\nseed_clauses::Vector{Vector{Int64}}\nWhich clauses get seeded upon matching of a clause\nterminals::Vector{Int64}\nA summarized list of grammar terminals that are checked against each input letter\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Many","page":"Reference","title":"PikaParser.Many","text":"struct Many{G} <: PikaParser.Clause{G}\n\nGreedily matches a sequence of matches that can be empty.\n\nFields\n\nitem::Any\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Match","page":"Reference","title":"PikaParser.Match","text":"struct Match\n\nInternal match representation.\n\nFields\n\nclause::Int64\nWhich clause has matched here?\npos::Int64\nWhere the match started?\nlen::Int64\nHow long is the match?\noption_idx::Int64\nWhich possibility (given by the clause) did we match?\nsubmatches::Vector{Int64}\nIndexes to the vector of matches. This forms the edges in the match tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.MemoKey","page":"Reference","title":"PikaParser.MemoKey","text":"struct MemoKey\n\nIndex into the memoization table.\n\nFields\n\nclause::Int64\npos::Int64\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.MemoTable","page":"Reference","title":"PikaParser.MemoTable","text":"mutable struct SortedDict{PikaParser.MemoKey, Int64, Ord<:Base.Order.Ordering} <: AbstractDict{PikaParser.MemoKey, Int64}\n\nPikaparser memoization table.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.NotFollowedBy","page":"Reference","title":"PikaParser.NotFollowedBy","text":"struct NotFollowedBy{G} <: PikaParser.Clause{G}\n\nZero-length match that succeeds if reserved does not match at the same position.\n\nFields\n\nreserved::Any\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.ParserState","page":"Reference","title":"PikaParser.ParserState","text":"mutable struct ParserState{G, I}\n\nIntermediate parsing state. The match tree is built in a vector of matches that grows during the matching, all match indexes point into this vector.\n\nThis structure is also a \"result\" of the parsing, used to reconstruct the match tree.\n\nFields\n\ngrammar::PikaParser.Grammar\nCopy of the grammar used to parse the input.\nmemo::DataStructures.SortedDict{PikaParser.MemoKey, Int64}\nBest matches of grammar rules for each position of the input\nq::DataStructures.SortedSet{Int64}\nQueue for rules that should match, used only internally.\nmatches::Vector{PikaParser.Match}\nMatch tree (folded into a vector)\ninput::Any\nParser input, can be used to reconstruct match data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Satisfy","page":"Reference","title":"PikaParser.Satisfy","text":"struct Satisfy{G} <: PikaParser.Clause{G}\n\nA single terminal. Matches a token from the input stream where the match function returns true.\n\nFields\n\nmatch::Function\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Scan","page":"Reference","title":"PikaParser.Scan","text":"struct Scan{G} <: PikaParser.Clause{G}\n\nA single terminal, possibly made out of multiple input tokens.\n\nGiven the input stream and a position in it, the match function scans the input forward and returns the length of the terminal starting at the position. In case there's no match, it returns nothing.\n\nFields\n\nmatch::Function\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Seq","page":"Reference","title":"PikaParser.Seq","text":"struct Seq{G} <: PikaParser.Clause{G}\n\nSequence of matches. Empty Seq is equivalent to an always-succeeding empty match, as in Epsilon.\n\nFields\n\nchildren::Vector\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Some","page":"Reference","title":"PikaParser.Some","text":"struct Some{G} <: PikaParser.Clause{G}\n\nGreedily matches a sequence of matches, with at least 1 match.\n\nFields\n\nitem::Any\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Tie","page":"Reference","title":"PikaParser.Tie","text":"struct Tie{G} <: PikaParser.Clause{G}\n\nProduces the very same match as the item, but concatenates the user views of the resulting submatches into one big vector. (Thus basically squashing the 2 levels of child matches to a single one.) Useful e.g. for lists with different initial or final elements. (As a result, the item and its immediate children are not going to be present in the parse tree.)\n\nFields\n\ntuple::Any\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Token","page":"Reference","title":"PikaParser.Token","text":"struct Token{G} <: PikaParser.Clause{G}\n\nA single token equal to match.\n\nFields\n\ntoken::Any\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.Tokens","page":"Reference","title":"PikaParser.Tokens","text":"struct Tokens{G} <: PikaParser.Clause{G}\n\nA series of tokens equal to match.\n\nFields\n\ntokens::Vector\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.TraverseNode","page":"Reference","title":"PikaParser.TraverseNode","text":"mutable struct TraverseNode{G}\n\nPart of intermediate tree traversing state.\n\nFields\n\nparent_idx::Int64\nparent_sub_idx::Int64\nrule::Any\nmatch::PikaParser.UserMatch\nopen::Bool\nsubvals::Vector\n\n\n\n\n\n","category":"type"},{"location":"reference/#PikaParser.UserMatch","page":"Reference","title":"PikaParser.UserMatch","text":"struct UserMatch\n\nUser-facing representation of a Match.\n\nFields\n\npos::Int64\nWhere the match started?\nlen::Int64\nHow long is the match?\nsubmatches::Vector{Int64}\nIndexes and rule labels of the matched submatches. This forms the edges in the match tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Preparing-the-grammar","page":"Reference","title":"Preparing the grammar","text":"","category":"section"},{"location":"reference/#Specifying-rules","page":"Reference","title":"Specifying rules","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PikaParser]\nPages = [\"frontend.jl\"]","category":"page"},{"location":"reference/#PikaParser.epsilon","page":"Reference","title":"PikaParser.epsilon","text":"epsilon :: Clause\n\nAn Epsilon clause. Translate to strongly typed grammar with flatten.\n\nExample\n\nmaybe_letter_a = first(token('a'), epsilon)\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PikaParser.fail","page":"Reference","title":"PikaParser.fail","text":"fail :: Clause\n\nA Fail clause. Translate to strongly typed grammar with flatten.\n\nUseful for avoiding rule specification when matching terminals using the fast_match parameter of parse.\n\nExample\n\nseq(:this, :that, fail)  # this rule is effectively disabled\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PikaParser.first-Tuple","page":"Reference","title":"PikaParser.first","text":"first(args...) -> PikaParser.First\n\n\nBuild a First clause. Translate to strongly typed grammar with flatten.\n\nExample\n\nfirst(:something, :fallback, :fallback2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G","page":"Reference","title":"PikaParser.flatten","text":"flatten(rules::Dict{G}) -> Dict\nflatten(rules::Dict{G}, childlabel::Function) -> Dict\n\n\nConvert a possibly nested and weakly typed rules into a correctly typed and unnested ruleset, usable in make_grammar. This allows use of convenience rule building functions:\n\nsatisfy\nscan\ntoken\ntokens\nepsilon (not a function!)\nfail (not a function!)\nseq\nfirst\nnot_followed_by\nfollowed_by\nsome\nmany\ntie\nprecedence_cascade (not backed by an actual Clause!)\n\nAnonymous nested rules are assigned names that are constructed by childlabel function (gets the original G and and integer with position integer). By default, childlabel concatenats the parent rule name, hyphen, and the position number to form a Symbol (i.e., the default works only in cases when the rules are labeled by Symbols, and you need to provide your own implementation for other grammars labeled e.g. by integers or strings).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.followed_by-Tuple{Any}","page":"Reference","title":"PikaParser.followed_by","text":"followed_by(x) -> PikaParser.FollowedBy\n\n\nBuild a FollowedBy clause. Translate to strongly typed grammar with flatten.\n\nExample\n\nseq(:digits, followed_by(:whitespace))\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.many-Tuple{Any}","page":"Reference","title":"PikaParser.many","text":"many(x) -> PikaParser.Many\n\n\nBuild a Many clause. Translate to strongly typed grammar with flatten.\n\nExample\n\nseq(:quote, many(:quote_contents), :quote)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.not_followed_by-Tuple{Any}","page":"Reference","title":"PikaParser.not_followed_by","text":"not_followed_by(x) -> PikaParser.NotFollowedBy\n\n\nBuild a NotFollowedBy clause. Translate to strongly typed grammar with flatten.\n\nExample\n\nseq(not_followed_by(tokens(collect(\"reservedWord\"))), :identifier)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.precedence_cascade-Tuple{Function, Vararg{Any}}","page":"Reference","title":"PikaParser.precedence_cascade","text":"precedence_cascade(label::Function, levels...) -> Vector\n\n\nConvert a list of rules of increasing associativity to a typical precedence-handling \"failthrough\" construction. The result must be post-processed by flatten.\n\nEach of the rules is abstracted by \"same-associativity\" and \"higher-associativity\" rules (i.e., it is a binary function), which is used to correctly link the rules within the precedence group. The first rule is of the lowest precedence. All rules except the last automatically fallback to the next rule. The higher-precedence parameter of the last rule is the label of the first rule.\n\nlabel is a function that generates the label for given n-th level of the grammar.\n\nUse @precedences for a less verbose construction.\n\nReturns a vector of labeled rules; that must usually be interpolated into the ruleset.\n\nExample\n\nDict(\n    precedence_cascade(\n        n -> Symbol(:exprlevel, n),\n        (same, next) -> :expr => first(\n            :plus => seq(same, token('+'), next),\n            :minus => seq(same, token('-'), next),\n        ),\n        (same, next) -> :times => seq(same, token('*'), next), # left associative\n        (same, next) -> :power => seq(next, token('^'), same), # right associative\n        (_, restart) -> first(\n            :parens => seq(token('('), restart, token(')')),\n            :digits => some(satisfy(isdigit)),\n        ),\n    )...,\n)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.satisfy-Tuple{Function}","page":"Reference","title":"PikaParser.satisfy","text":"satisfy(f::Function) -> PikaParser.Satisfy{Any}\n\n\nBuild a Satisfy clause. Translate to strongly typed grammar with flatten.\n\nExample\n\nsatisfy(isdigit)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.scan-Tuple{Function}","page":"Reference","title":"PikaParser.scan","text":"scan(f::Function) -> PikaParser.Scan{Any}\n\n\nBuild a Scan clause. Translate to strongly typed grammar with flatten.\n\nExample\n\n# rule to match a pair of equal tokens\nscan(m -> m[1] == m[2] ? 2 : nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.seq-Tuple","page":"Reference","title":"PikaParser.seq","text":"seq(args...) -> PikaParser.Seq\n\n\nBuild a Seq clause. Translate to strongly typed grammar with flatten.\n\nExample\n\ndigit_in_parents = seq(token('('), :digit, token(')'))\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.some-Tuple{Any}","page":"Reference","title":"PikaParser.some","text":"some(x) -> PikaParser.Some\n\n\nBuild a Some clause. Translate to strongly typed grammar with flatten.\n\nExample\n\nsome(satisfy(isspace))\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.tie-Tuple{Any}","page":"Reference","title":"PikaParser.tie","text":"tie(x) -> PikaParser.Tie\n\n\nBuild a Tie clause. Translate to strongly typed grammar with flatten.\n\nExample\n\n:alternating_A_and_B => tie(many(seq(:A, :B)))\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.token-Tuple{Any}","page":"Reference","title":"PikaParser.token","text":"token(x) -> PikaParser.Token{Any}\n\n\nBuild a Token clause. Translate to strongly typed grammar with flatten.\n\nExample\n\ntoken('a')\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.tokens-Tuple{Vector}","page":"Reference","title":"PikaParser.tokens","text":"tokens(xs::Vector) -> PikaParser.Tokens{Any}\n\n\nBuild a Tokens clause. Translate to strongly typed grammar with flatten.\n\nExample\n\ntokens(collect(\"keyword\"))\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.@precedences-Tuple{Any, Symbol, Symbol, Any}","page":"Reference","title":"PikaParser.@precedences","text":"@precedences labeller same::Symbol next::Symbol rules\n\nA shortcut macro for precedence_cascade. Automatically adds lambda heads with fixed argument names, and splats itself with ... into the surrounding environment.\n\nExample\n\nDict(\n    @precedences (n->Symbol(:exprlevel, n)) same next begin\n        :expr => seq(same, token('+'), next)\n        seq(same, token('*'), next)\n        first(\n            token('x'),\n            seq(token('('), next, token(')'))\n        )\n    end\n)\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Converting-to-a-Grammar","page":"Reference","title":"Converting to a Grammar","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PikaParser]\nPages = [\"grammar.jl\"]","category":"page"},{"location":"reference/#PikaParser.make_grammar-Union{Tuple{G}, Tuple{AbstractVector{G}, Dict{G, PikaParser.Clause{G}}}} where G","page":"Reference","title":"PikaParser.make_grammar","text":"make_grammar(starts::AbstractArray{G, 1}, rules_dict::Dict{G, PikaParser.Clause{G}}) -> PikaParser.Grammar\n\n\nProduce a Grammar with rules of type G that can be used to parse inputs.\n\nstarts should collect top-level rules (these will be put at the top of the topological order of the parsing).\n\nrules_dict is a dictionary of grammar Clauses.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Parsing","page":"Reference","title":"Parsing","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PikaParser]\nPages = [\"parse.jl\"]","category":"page"},{"location":"reference/#PikaParser.parse-Union{Tuple{I}, Tuple{G}, Tuple{PikaParser.Grammar{G}, I}, Tuple{PikaParser.Grammar{G}, I, Any}} where {G, I<:(AbstractVector)}","page":"Reference","title":"PikaParser.parse","text":"parse(grammar::PikaParser.Grammar{G}, input::AbstractVector) -> PikaParser.ParserState\nparse(grammar::PikaParser.Grammar{G}, input::AbstractVector, fast_match) -> PikaParser.ParserState\n\n\nTake a Grammar and an indexable input sequence, and return a final ParserState that contains all matched grammar productions.\n\nFast terminal matching\n\nIf fast_match is specified, the function does not match terminals using the associated grammar rules, but with a fast_match function that reports the matched terminals via a callback. The function is called exactly once for each position in input in reverse order (i.e., the indexes will follow reverse(1:length(input)), which can be utilized by the application for optimization).  The call parameters consist of the input vector, position in the input vector, and a \"report\" function used to send back a clause ID (of same type as G in typeof(grammar)) and the length of the terminal matches that can found at that position. Calls to the reporting function can be repeated if more terminal types match. Terminals not reported by the calls to fast_match will not be matched.\n\nFor complicated grammars, this may be much faster than having the parser to try matching all terminal types at each position.\n\nResults\n\nUse find_first_parse_at or find_match_at! to extract matches from ParserState.\n\nPika parsing never really fails. Instead, in case when the grammar rule is not matched in the input, the expected rule match match is either not going to be found at the starting position with find_match_at!, or it will not span the whole input.\n\nExample\n\nparse(\n    g,\n    collect(\"abcde123\"),\n    (input, i, match) -> isdigit(input[i]) ? match(:digit, 1) : match(:letter, 1),\n)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Traversing-and-folding-the-parse-tree","page":"Reference","title":"Traversing and folding the parse tree","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PikaParser]\nPages = [\"traverse.jl\"]","category":"page"},{"location":"reference/#PikaParser.default_fold-Tuple{Any, Any, Any}","page":"Reference","title":"PikaParser.default_fold","text":"default_fold(rule, umatch, subvals) -> Expr\n\n\nThe default function used as fold argument in traverse_match.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.default_open-Tuple{Any, Any}","page":"Reference","title":"PikaParser.default_open","text":"default_open(rule, umatch) -> Base.Generator{_A, PikaParser.var\"#29#30\"} where _A\n\n\nThe default function used as open argument in traverse_match.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.find_first_parse_at-Union{Tuple{G}, Tuple{PikaParser.ParserState{G}, Int64}} where G","page":"Reference","title":"PikaParser.find_first_parse_at","text":"Find any possible match of anything starting at input position pos. Preferentially returns the parses that are topologically higher.\n\nIf found, returns the Match index in ParserState, and the name of the corresponding grammar production rule.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.find_match_at!-Union{Tuple{G}, Tuple{PikaParser.ParserState{G}, G, Int64}} where G","page":"Reference","title":"PikaParser.find_match_at!","text":"find_match_at!(st::PikaParser.ParserState{G}, rule, pos::Int64) -> Union{Nothing, Int64}\n\n\nFind the Match index in ParserState that matched rule at position pos, or nothing if there is no such match.\n\nZero-length matches may not be matched at all positions by default; this function creates the necessary matches in the tables in st in case they are missing. (That is the reason for the ! label.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.traverse_match-Union{Tuple{G}, Tuple{PikaParser.ParserState{G}, Int64}} where G","page":"Reference","title":"PikaParser.traverse_match","text":"traverse_match(st::PikaParser.ParserState{G}, mid::Int64; open, fold) -> Expr\n\n\nGiven a Match index in ParserState st, recusively depth-first traverse the match tree using functions open (called upon entering a submatch) and fold (called upon leaving the submatch).\n\nopen is given the current grammar rule and the UserMatch. It should return a vector of boolean values that tell the traversal which submatches from the UserMatch should be opened. That can be used to skip parsing of large uninteresting parts of the match tree, such as whitespace or comments. By default, it opens the whole subtree.\n\nfold is given the same current grammar rule and the UserMatch, and additionally a vector of folded values from the submatches. The values returned by fold invocations are collected and transferred to higher-level invocations of fold. In case open disabled the evaluation of a given submatch, nothing is used as the folded value for the submatch. The default open and fold (default_open, default_fold) just collect all submatch values and produce a Julia Expr AST structure where rule expansions are represented as function calls.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.view_match-Tuple{PikaParser.ParserState, Int64}","page":"Reference","title":"PikaParser.view_match","text":"view_match(st::PikaParser.ParserState, mid::Int64) -> Any\n\n\nGet a view of input that corresponds to the match identified by given match ID.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PikaParser.view_match-Tuple{PikaParser.ParserState, Union{PikaParser.Match, PikaParser.UserMatch}}","page":"Reference","title":"PikaParser.view_match","text":"view_match(st::PikaParser.ParserState, match::Union{PikaParser.Match, PikaParser.UserMatch}) -> Any\n\n\nGet a view of input that corresponds to the given match. Useful for parsing out terminals.\n\n\n\n\n\n","category":"method"},{"location":"#PikaParser.jl","page":"README","title":"PikaParser.jl","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"Modules = [PikaParser]\nPages = [\"PikaParser.jl\"]","category":"page"},{"location":"#PikaParser.PikaParser","page":"README","title":"PikaParser.PikaParser","text":"PikaParser.jl\n\nA simple straightforward implementation of PikaParser in pure Julia, following the specification by Luke A. D. Hutchison (see https://github.com/lukehutch/pikaparser).\n\nPika parsers are pretty fast, they are easy to specify, carry the ability to unambigously match all PEG grammars including the left-recursive ones, and provide great mechanisms for parsing error recovery.\n\nThe code is new, feedback is welcome.\n\nExample\n\nimport PikaParser as P\n\nBuilding a grammar\n\nAll grammar clauses are subtype of a Clause. The types are indexed by the labels for your grammar rules â€“ Julia symbols are a natural choice, but you are free to use integers, strings, or anything else.\n\nrules = Dict(\n    # match a sequence of characters that satisfies `isdigit`\n    :digits => P.some(:digit => P.satisfy(isdigit)),\n\n    # expression in parentheses\n    :parens => P.seq(\n        P.token('('),\n        # you can name the rules in nested contexts\n        :expr => P.first(:plusexpr, :minusexpr, :digits, :parens),\n        P.token(')'),\n    ),\n\n    # some random operators\n    :plusexpr => P.seq(:expr, P.token('+'), :expr),\n    :minusexpr => P.seq(:expr, P.token('-'), :expr),\n)\n\ng = P.make_grammar(\n    [:expr], # the top-level rule\n    P.flatten(rules),\n)\n\nThe grammar is now prepared for parsing.\n\nParsing text\n\nPika parsers require frequent indexing of the input, Strings thus need to be converted to character vectors to be usable as parser input. (To improve performance, it is adviseable to lex your input into a vector of more complex tokens.)\n\ninput = collect(\"12-(34+567-8)\")\np = P.parse(g, input)\n\nYou can find if an expression was matched at a certain position:\n\nP.find_match_at!(p, :expr, 1)\n\n...which returns an index in the match table (if found), such as 45.\n\nYou can have a look at the match. p.matches[45] should return:\n\nPikaParser.Match(10, 1, 13, 2, [44])\n\nwhere 10 is the renumbered rule ID for :expr, 1 is the starting position in the input, 13 is the length of the match (here, that is the whole input); 2 is the option index (in this case, it points to :expr option 2, which is :minusexpr), and 44 is the submatch of :minusexpr.\n\nRecovering parsed ASTs\n\nYou can use traverse_match to recursively walk the parse trees, to produce ASTs, and translate, interpret or evaluate the expressions:\n\nP.traverse_match(p, P.find_match_at!(p, :expr, 1))\n\nBy default, this runs through the whole match tree and transcodes the matches to Julia Expr AST. In this case, if you pipe the output through JuliaFormatter, you will get something like:\n\nexpr(\n    minusexpr(\n        expr(digits(digit(), digit())),\n        var\"minusexpr-2\"(),\n        expr(\n            parens(\n                var\"parens-1\"(),\n                expr(\n                    plusexpr(\n                        expr(digits(digit(), digit())),\n                        var\"plusexpr-2\"(),\n                        expr(\n                            minusexpr(\n                                expr(digits(digit(), digit(), digit())),\n                                var\"minusexpr-2\"(),\n                                expr(digits(digit())),\n                            ),\n                        ),\n                    ),\n                ),\n                var\"parens-3\"(),\n            ),\n        ),\n    ),\n)\n\nIt is straightforward to specify your own method of evaluating the parses by supplying the matchtree opening and folding functions. For example, you can evaluate the expression as follows:\n\nP.traverse_match(p, P.find_match_at!(p, :expr, 1),\n    fold = (rule, match, subvals) ->\n        rule == :digits ?\n        parse(Int, String(input[match.pos:match.pos+match.len-1])) :\n        rule == :expr ? subvals[1] :\n        rule == :parens ? subvals[2] :\n        rule == :plusexpr ? subvals[1] + subvals[3] :\n        rule == :minusexpr ? subvals[1] - subvals[3] :\n        nothing,\n)\n\nYou should get the expectable result (-581).\n\n\n\n\n\n","category":"module"}]
}
