<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PikaParser.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://lcsb-biocore.github.io/PikaParser.jl/stable/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PikaParser.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../json/">Example: Parsing JSON</a></li><li><a class="tocitem" href="../scheme/">Example: Parsing Scheme</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Data-types"><span>Data types</span></a></li><li><a class="tocitem" href="#Preparing-the-grammar"><span>Preparing the grammar</span></a></li><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#Traversing-and-folding-the-parse-tree"><span>Traversing and folding the parse tree</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Data-types"><a class="docs-heading-anchor" href="#Data-types">Data types</a><a id="Data-types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Clause" href="#PikaParser.Clause"><code>PikaParser.Clause</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Clause{G, T}</code></pre><p>Abstract type for all clauses that match a grammar with rule labels of type <code>G</code> that match sequences of tokens of type <code>T</code>.</p><p>Currently implemented clauses:</p><ul><li><a href="#PikaParser.Satisfy"><code>Satisfy</code></a></li><li><a href="#PikaParser.Scan"><code>Scan</code></a></li><li><a href="#PikaParser.Token"><code>Token</code></a></li><li><a href="#PikaParser.Tokens"><code>Tokens</code></a></li><li><a href="#PikaParser.Epsilon"><code>Epsilon</code></a></li><li><a href="#PikaParser.Fail"><code>Fail</code></a></li><li><a href="#PikaParser.EndOfInput"><code>EndOfInput</code></a></li><li><a href="#PikaParser.Seq"><code>Seq</code></a></li><li><a href="#PikaParser.First"><code>First</code></a></li><li><a href="#PikaParser.NotFollowedBy"><code>NotFollowedBy</code></a></li><li><a href="#PikaParser.FollowedBy"><code>FollowedBy</code></a></li><li><a href="#PikaParser.Some"><code>Some</code></a></li><li><a href="#PikaParser.Many"><code>Many</code></a></li><li><a href="#PikaParser.Tie"><code>Tie</code></a></li></ul><p>Often it is better to use convenience functions for rule construction, such as <a href="#PikaParser.seq-Tuple"><code>seq</code></a> or <a href="#PikaParser.token-Tuple{T} where T"><code>token</code></a>; see <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.EndOfInput" href="#PikaParser.EndOfInput"><code>PikaParser.EndOfInput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EndOfInput{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>Matches at the end of the input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Epsilon" href="#PikaParser.Epsilon"><code>PikaParser.Epsilon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Epsilon{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>An always-succeeding epsilon match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Fail" href="#PikaParser.Fail"><code>PikaParser.Fail</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Fail{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>An always-failing match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.First" href="#PikaParser.First"><code>PikaParser.First</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct First{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>Match the first possibility of several matches. Empty <code>First</code> is equivalent to unconditional failure.</p><p><strong>Fields</strong></p><ul><li><code>children::Vector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.FollowedBy" href="#PikaParser.FollowedBy"><code>PikaParser.FollowedBy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FollowedBy{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>Zero-length match that succeeds if <code>follow</code> does match at the same position.</p><p><strong>Fields</strong></p><ul><li><code>follow::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Grammar" href="#PikaParser.Grammar"><code>PikaParser.Grammar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Grammar{G, T}</code></pre><p>A representation of the grammar prepared for parsing.</p><p><strong>Fields</strong></p><ul><li><p><code>names::Vector</code>: Topologically sorted list of rule labels (non-terminals)</p></li><li><p><code>idx::Dict{G, Int64} where G</code>: Mapping of rule labels to their indexes in <code>names</code></p></li><li><p><code>clauses::Array{PikaParser.Clause{Int64, T}, 1} where T</code>: Clauses of the grammar converted to integer labels (and again sorted topologically)</p></li><li><p><code>can_match_epsilon::Vector{Bool}</code>: Flags for the rules being able to match on empty string unconditionally</p></li><li><p><code>seed_clauses::Vector{Vector{Int64}}</code>: Which clauses get seeded upon matching of a clause</p></li><li><p><code>terminals::Vector{Int64}</code>: Sorted indexes of terminal clauses that are checked against each input item.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Many" href="#PikaParser.Many"><code>PikaParser.Many</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Many{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>Greedily matches a sequence of matches that can be empty.</p><p><strong>Fields</strong></p><ul><li><code>item::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Match" href="#PikaParser.Match"><code>PikaParser.Match</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Match</code></pre><p>Internal match representation.</p><p><strong>Fields</strong></p><ul><li><p><code>clause::Int64</code>: Which clause has matched here?</p></li><li><p><code>first::Int64</code>: Where the match started?</p></li><li><p><code>last::Int64</code>: What is the last item of the match? (In case of empty match, this MUST be the previous index before <code>first</code>, i.e., <code>prevind(input, first)</code>.)</p></li><li><p><code>option_idx::Int64</code>: Which possibility (given by the clause) did we match?</p></li><li><p><code>submatches::Int64</code>: Index to the first submatch, the range of submatches spans all the way to the first submatch of the next Match.</p></li><li><p><code>left::Int64</code>: Left child in the memo tree.</p></li><li><p><code>right::Int64</code>: Right child in the memo tree.</p></li><li><p><code>parent::Int64</code>: Parent in the memo tree.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.MatchResult" href="#PikaParser.MatchResult"><code>PikaParser.MatchResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">primitive type Int64 &lt;: Signed 64</code></pre><p>A match index in <a href="#PikaParser.ParserState"><code>ParserState</code></a> field <code>matches</code>, or <code>nothing</code> if the match failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.NotFollowedBy" href="#PikaParser.NotFollowedBy"><code>PikaParser.NotFollowedBy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotFollowedBy{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>Zero-length match that succeeds if <code>reserved</code> does <em>not</em> match at the same position.</p><p><strong>Fields</strong></p><ul><li><code>reserved::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.ParserState" href="#PikaParser.ParserState"><code>PikaParser.ParserState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ParserState{G, T, I}</code></pre><p>Intermediate parsing state. The match tree is built in a vector of matches that grows during the matching, all match indexes point into this vector.</p><p>This structure is also a &quot;result&quot; of the parsing, used to reconstruct the match tree.</p><p><strong>Fields</strong></p><ul><li><p><code>grammar::PikaParser.Grammar</code>: Copy of the grammar used to parse the input.</p></li><li><p><code>q::PikaParser.PikaQueue</code>: Queue for rules that should match, used only internally.</p></li><li><p><code>matches::Vector{PikaParser.Match}</code>: Matches, connected by indexes to form a memo table search tree.</p></li><li><p><code>memo_root::Int64</code>: Root of the memotable search tree (stored in the <code>matches</code>).</p></li><li><p><code>submatches::Vector{Int64}</code>: Children pointers of the matches that form the match tree.</p></li><li><p><code>input::Any</code>: Parser input, used to reconstruct match data.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Satisfy" href="#PikaParser.Satisfy"><code>PikaParser.Satisfy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Satisfy{G, T} &lt;: PikaParser.Terminal{G, T}</code></pre><p>A single terminal. Matches a token from the input stream where the <code>match</code> function returns <code>true</code>, otherwise it returns <code>false</code>.</p><p><strong>Fields</strong></p><ul><li><code>match::Function</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Scan" href="#PikaParser.Scan"><code>PikaParser.Scan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Scan{G, T} &lt;: PikaParser.Terminal{G, T}</code></pre><p>A single terminal, possibly made out of multiple input tokens.</p><p>Given the input stream view, the <code>match</code> function scans the input forward and returns the position of the last item of the terminal starting at the beginning of the stream. In case there&#39;s no match, it returns a zero.</p><p><strong>Fields</strong></p><ul><li><code>match::Function</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Seq" href="#PikaParser.Seq"><code>PikaParser.Seq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Seq{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>Sequence of matches. Empty <code>Seq</code> is equivalent to an always-succeeding empty match, as in <a href="#PikaParser.Epsilon"><code>Epsilon</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>children::Vector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Some" href="#PikaParser.Some"><code>PikaParser.Some</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Some{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>Greedily matches a sequence of matches, with at least 1 match.</p><p><strong>Fields</strong></p><ul><li><code>item::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Tie" href="#PikaParser.Tie"><code>PikaParser.Tie</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Tie{G, T} &lt;: PikaParser.Clause{G, T}</code></pre><p>Produces the very same match as the <code>item</code>, but concatenates the user views of the resulting submatches into one big vector (i.e., basically squashing the 2 levels of child matches to a single one.) Useful e.g. for lists with different initial or final elements.</p><p>As a result, the <code>item</code> and its immediate children are <em>not</em> going to be present in the parse tree.</p><p><strong>Fields</strong></p><ul><li><code>tuple::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Token" href="#PikaParser.Token"><code>PikaParser.Token</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Token{G, T} &lt;: PikaParser.Terminal{G, T}</code></pre><p>A single token equal to <code>match</code>.</p><p><strong>Fields</strong></p><ul><li><code>token::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Tokens" href="#PikaParser.Tokens"><code>PikaParser.Tokens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Tokens{G, T, I} &lt;: PikaParser.Terminal{G, T}</code></pre><p>A series of tokens equal to <code>match</code>.</p><p><strong>Fields</strong></p><ul><li><code>tokens::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.TraverseNode" href="#PikaParser.TraverseNode"><code>PikaParser.TraverseNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct TraverseNode{G, S}</code></pre><p>Part of intermediate tree traversing state.</p><p><strong>Fields</strong></p><ul><li><p><code>parent_idx::Int64</code></p></li><li><p><code>parent_sub_idx::Int64</code></p></li><li><p><code>match::PikaParser.UserMatch</code></p></li><li><p><code>open::Bool</code></p></li><li><p><code>subvals::Vector</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.UserMatch" href="#PikaParser.UserMatch"><code>PikaParser.UserMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UserMatch{G, S}</code></pre><p>User-facing representation of a <a href="#PikaParser.Match"><code>Match</code></a>.</p><p><strong>Fields</strong></p><ul><li><p><code>rule::Any</code>: Which rule ID has matched here?</p></li><li><p><code>first::Int64</code>: Where the match started?</p></li><li><p><code>last::Int64</code>: What is the last item of the match? (In case of empty match, this is the previous index before <code>first</code>.)</p></li><li><p><code>view::Any</code>: View of the matched part of the input, usually a <code>SubArray</code> or <code>SubString</code>.</p></li><li><p><code>submatches::Vector{Int64}</code>: Indexes and rule labels of the matched submatches. This forms the edges in the match tree.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/structs.jl#L281">source</a></section></article><h2 id="Preparing-the-grammar"><a class="docs-heading-anchor" href="#Preparing-the-grammar">Preparing the grammar</a><a id="Preparing-the-grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Preparing-the-grammar" title="Permalink"></a></h2><h3 id="Specifying-rules"><a class="docs-heading-anchor" href="#Specifying-rules">Specifying rules</a><a id="Specifying-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-rules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PikaParser.end_of_input" href="#PikaParser.end_of_input"><code>PikaParser.end_of_input</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">end_of_input :: Clause</code></pre><p>An <a href="#PikaParser.EndOfInput"><code>EndOfInput</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">whole_file = first(:file_contents, end_of_input)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.epsilon" href="#PikaParser.epsilon"><code>PikaParser.epsilon</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">epsilon :: Clause</code></pre><p>An <a href="#PikaParser.Epsilon"><code>Epsilon</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">maybe_letter_a = first(token(&#39;a&#39;), epsilon)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.fail" href="#PikaParser.fail"><code>PikaParser.fail</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">fail :: Clause</code></pre><p>A <a href="#PikaParser.Fail"><code>Fail</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p>Useful for avoiding rule specification when matching terminals using the <code>fast_match</code> parameter of <a href="#PikaParser.parse-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}, Tuple{PikaParser.Grammar{G, T}, I, Any}} where {G, T, I}"><code>parse</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">seq(:this, :that, fail)  # this rule is effectively disabled</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.first-Tuple" href="#PikaParser.first-Tuple"><code>PikaParser.first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">first(args...) -&gt; PikaParser.First{Any, Any}
</code></pre><p>Build a <a href="#PikaParser.First"><code>First</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">first(:something, :fallback, :fallback2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G" href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>PikaParser.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten(rules::Dict{G}, tokentype::DataType) -&gt; Dict
flatten(
    rules::Dict{G},
    tokentype::DataType,
    childlabel::Function
) -&gt; Dict
</code></pre><p>Convert a possibly nested and weakly typed <code>rules</code> into a correctly typed and unnested ruleset, usable in <a href="#PikaParser.make_grammar-Union{Tuple{T}, Tuple{G}, Tuple{AbstractVector{G}, Dict{G, PikaParser.Clause{G, T}}}} where {G, T}"><code>make_grammar</code></a>. This allows use of convenience rule building functions:</p><ul><li><a href="#PikaParser.satisfy-Tuple{Function}"><code>satisfy</code></a></li><li><a href="#PikaParser.scan-Tuple{Function}"><code>scan</code></a></li><li><a href="#PikaParser.token-Tuple{T} where T"><code>token</code></a></li><li><a href="#PikaParser.tokens-Tuple{I} where I"><code>tokens</code></a></li><li><a href="#PikaParser.epsilon"><code>epsilon</code></a> (not a function!)</li><li><a href="#PikaParser.fail"><code>fail</code></a> (not a function!)</li><li><a href="#PikaParser.seq-Tuple"><code>seq</code></a></li><li><a href="#PikaParser.first-Tuple"><code>first</code></a></li><li><a href="#PikaParser.not_followed_by-Tuple{G} where G"><code>not_followed_by</code></a></li><li><a href="#PikaParser.followed_by-Tuple{G} where G"><code>followed_by</code></a></li><li><a href="#PikaParser.some-Tuple{G} where G"><code>some</code></a></li><li><a href="#PikaParser.many-Tuple{G} where G"><code>many</code></a></li><li><a href="#PikaParser.tie-Tuple{G} where G"><code>tie</code></a></li><li><a href="#PikaParser.precedence_cascade-Tuple{Function, Vararg{Any}}"><code>precedence_cascade</code></a> (not backed by an actual <a href="#PikaParser.Clause"><code>Clause</code></a>!)</li></ul><p>Anonymous nested rules are assigned names that are constructed by <code>childlabel</code> function (gets the original G and and integer with position integer). By default, <code>childlabel</code> concatenates the parent rule name, hyphen, and the position number to form a <code>Symbol</code> (i.e., the default works only in cases when the rules are labeled by Symbols, and you need to provide your own implementation for other grammars labeled e.g. by integers or strings).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.followed_by-Tuple{G} where G" href="#PikaParser.followed_by-Tuple{G} where G"><code>PikaParser.followed_by</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">followed_by(x) -&gt; PikaParser.FollowedBy{_A, Any} where _A
</code></pre><p>Build a <a href="#PikaParser.FollowedBy"><code>FollowedBy</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">seq(:digits, followed_by(:whitespace))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.many-Tuple{G} where G" href="#PikaParser.many-Tuple{G} where G"><code>PikaParser.many</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">many(x) -&gt; PikaParser.Many{_A, Any} where _A
</code></pre><p>Build a <a href="#PikaParser.Many"><code>Many</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">seq(:quote, many(:quote_contents), :quote)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.not_followed_by-Tuple{G} where G" href="#PikaParser.not_followed_by-Tuple{G} where G"><code>PikaParser.not_followed_by</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">not_followed_by(
    x
) -&gt; PikaParser.NotFollowedBy{_A, Any} where _A
</code></pre><p>Build a <a href="#PikaParser.NotFollowedBy"><code>NotFollowedBy</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">seq(not_followed_by(tokens(collect(&quot;reservedWord&quot;))), :identifier)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.precedence_cascade-Tuple{Function, Vararg{Any}}" href="#PikaParser.precedence_cascade-Tuple{Function, Vararg{Any}}"><code>PikaParser.precedence_cascade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precedence_cascade(label::Function, levels...) -&gt; Vector
</code></pre><p>Convert a list of rules of increasing associativity to a typical precedence-handling &quot;failthrough&quot; construction. The result must be post-processed by <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p>Each of the rules is abstracted by &quot;same-associativity&quot; and &quot;higher-associativity&quot; rules (i.e., it is a binary function), which is used to correctly link the rules within the precedence group. The first rule is of the lowest precedence. All rules except the last automatically fallback to the next rule. The higher-precedence parameter of the last rule is the label of the first rule.</p><p><code>label</code> is a function that generates the label for given <code>n</code>-th level of the grammar.</p><p>Use <a href="#PikaParser.@precedences-Tuple{Any, Symbol, Symbol, Any}"><code>@precedences</code></a> for a less verbose construction.</p><p>Returns a vector of labeled rules; that must usually be interpolated into the ruleset.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Dict(
    precedence_cascade(
        n -&gt; Symbol(:exprlevel, n),
        (same, next) -&gt; :expr =&gt; first(
            :plus =&gt; seq(same, token(&#39;+&#39;), next),
            :minus =&gt; seq(same, token(&#39;-&#39;), next),
        ),
        (same, next) -&gt; :times =&gt; seq(same, token(&#39;*&#39;), next), # left associative
        (same, next) -&gt; :power =&gt; seq(next, token(&#39;^&#39;), same), # right associative
        (_, restart) -&gt; first(
            :parens =&gt; seq(token(&#39;(&#39;), restart, token(&#39;)&#39;)),
            :digits =&gt; some(satisfy(isdigit)),
        ),
    )...,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.satisfy-Tuple{Function}" href="#PikaParser.satisfy-Tuple{Function}"><code>PikaParser.satisfy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">satisfy(f::Function) -&gt; PikaParser.Satisfy{Any, Any}
</code></pre><p>Build a <a href="#PikaParser.Satisfy"><code>Satisfy</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">satisfy(isdigit)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.scan-Tuple{Function}" href="#PikaParser.scan-Tuple{Function}"><code>PikaParser.scan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scan(f::Function) -&gt; PikaParser.Scan{Any, Any}
</code></pre><p>Build a <a href="#PikaParser.Scan"><code>Scan</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs"># rule to match a pair of equal tokens
scan(m -&gt; m[1] == m[2] ? 2 : -1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.seq-Tuple" href="#PikaParser.seq-Tuple"><code>PikaParser.seq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seq(args...) -&gt; PikaParser.Seq{Any, Any}
</code></pre><p>Build a <a href="#PikaParser.Seq"><code>Seq</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">digit_in_parents = seq(token(&#39;(&#39;), :digit, token(&#39;)&#39;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.some-Tuple{G} where G" href="#PikaParser.some-Tuple{G} where G"><code>PikaParser.some</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">some(x) -&gt; PikaParser.Some{_A, Any} where _A
</code></pre><p>Build a <a href="#PikaParser.Some"><code>Some</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">some(satisfy(isspace))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.tie-Tuple{G} where G" href="#PikaParser.tie-Tuple{G} where G"><code>PikaParser.tie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tie(x) -&gt; PikaParser.Tie{_A, Any} where _A
</code></pre><p>Build a <a href="#PikaParser.Tie"><code>Tie</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">:alternating_A_and_B =&gt; tie(many(seq(:A, :B)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.token-Tuple{T} where T" href="#PikaParser.token-Tuple{T} where T"><code>PikaParser.token</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">token(x) -&gt; PikaParser.Token{Any}
</code></pre><p>Build a <a href="#PikaParser.Token"><code>Token</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">token(&#39;a&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.tokens-Tuple{I} where I" href="#PikaParser.tokens-Tuple{I} where I"><code>PikaParser.tokens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokens(xs) -&gt; PikaParser.Tokens{Any}
</code></pre><p>Build a <a href="#PikaParser.Tokens"><code>Tokens</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{G}, Tuple{Dict{G}, DataType}, Tuple{Dict{G}, DataType, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">tokens(&quot;keyword&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.@precedences-Tuple{Any, Symbol, Symbol, Any}" href="#PikaParser.@precedences-Tuple{Any, Symbol, Symbol, Any}"><code>PikaParser.@precedences</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@precedences labeller same::Symbol next::Symbol rules</code></pre><p>A shortcut macro for <a href="#PikaParser.precedence_cascade-Tuple{Function, Vararg{Any}}"><code>precedence_cascade</code></a>. Automatically adds lambda heads with fixed argument names, and splats itself with <code>...</code> into the surrounding environment.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Dict(
    @precedences (n-&gt;Symbol(:exprlevel, n)) same next begin
        :expr =&gt; seq(same, token(&#39;+&#39;), next)
        seq(same, token(&#39;*&#39;), next)
        first(
            token(&#39;x&#39;),
            seq(token(&#39;(&#39;), next, token(&#39;)&#39;))
        )
    end
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/frontend.jl#L224-L243">source</a></section></article><h3 id="Converting-to-a-Grammar"><a class="docs-heading-anchor" href="#Converting-to-a-Grammar">Converting to a <code>Grammar</code></a><a id="Converting-to-a-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-to-a-Grammar" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PikaParser.make_grammar-Union{Tuple{T}, Tuple{G}, Tuple{AbstractVector{G}, Dict{G, PikaParser.Clause{G, T}}}} where {G, T}" href="#PikaParser.make_grammar-Union{Tuple{T}, Tuple{G}, Tuple{AbstractVector{G}, Dict{G, PikaParser.Clause{G, T}}}} where {G, T}"><code>PikaParser.make_grammar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_grammar(
    starts::AbstractArray{G, 1},
    rules_dict::Dict{G, PikaParser.Clause{G, T}}
) -&gt; PikaParser.Grammar
</code></pre><p>Produce a <a href="#PikaParser.Grammar"><code>Grammar</code></a> with rules of type <code>G</code> that can be used to <a href="#PikaParser.parse-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}, Tuple{PikaParser.Grammar{G, T}, I, Any}} where {G, T, I}"><code>parse</code></a> inputs.</p><p><code>starts</code> should collect top-level rules (these will be put at the top of the topological order of the parsing).</p><p><code>rules_dict</code> is a dictionary of grammar <a href="#PikaParser.Clause"><code>Clause</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/grammar.jl#L2">source</a></section></article><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PikaParser.lex-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}} where {G, T, I}" href="#PikaParser.lex-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}} where {G, T, I}"><code>PikaParser.lex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lex(g::PikaParser.Grammar{G, T}, input) -&gt; Vector
</code></pre><p>Greedily find terminals in the input sequence, while avoiding any attempts at parsing terminals where another terminal was already parsed successfully.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/parse.jl#L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.parse-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}, Tuple{PikaParser.Grammar{G, T}, I, Any}} where {G, T, I}" href="#PikaParser.parse-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}, Tuple{PikaParser.Grammar{G, T}, I, Any}} where {G, T, I}"><code>PikaParser.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse(
    grammar::PikaParser.Grammar{G, T},
    input
) -&gt; PikaParser.ParserState
parse(
    grammar::PikaParser.Grammar{G, T},
    input,
    fast_match
) -&gt; PikaParser.ParserState
</code></pre><p>Take a <a href="#PikaParser.Grammar"><code>Grammar</code></a> and an indexable input sequence (typically <code>Vector</code> or <code>String</code>), and return a final <a href="#PikaParser.ParserState"><code>ParserState</code></a> that contains all matched grammar productions.</p><p>The <code>input</code> must be random-indexable (because PikaParsers require a lot of random indexing) using Int indexes, must support <code>firstindex</code>, <code>lastindex</code>, <code>prevind</code>, <code>nextind</code>, index arithmetics with <code>+</code> and <code>-</code>, and indexes in <code>view</code>s must be the same as in original container except for a constant offset.</p><p><strong>Lexing and fast terminal matching</strong></p><p>If <code>fast_match</code> is specified, the function does not match terminals using the associated grammar rules, but with a <code>fast_match</code> function that reports the matched terminals via a callback. The function is called exactly once for each position in <code>input</code> in reverse order (i.e., the indexes will start at <code>lastindex(input)</code> and continue using <code>prevind</code> all the way to <code>firstindex(input)</code>), which can be utilized by the application for optimization. The call parameters consist of the input vector, position in the input vector, and a &quot;report&quot; function used to send back a clause ID (of same type as <code>G</code> in <code>typeof(grammar)</code>) and the last item of the terminal match that can starts at that position. Calls to the reporting function can be repeated if more terminal types match. Terminals not reported by the calls to <code>fast_match</code> will not be matched.</p><p>For complicated grammars, this may be much faster than having the parser to try matching all terminal types at each position.</p><p>If your grammar does not contain dangerous or highly surprising kinds of terminals (in particular, it can be scanned greedily left-to-right), you may use <a href="#PikaParser.parse_lex-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}} where {G, T, I}"><code>parse_lex</code></a> to run a reasonable terminal-only lexing step, which is then automatically used as a basis for fast matching.</p><p><strong>Caveats</strong></p><p>Take care when indexing <code>String</code>s. With UTF-8, not all codepoints may necessarily have length 1.</p><p>If unsure, you may always <code>collect</code> the strings to vectors of <code>Char</code>s (basically converting to UTF-32), where each character occupies precisely one index.</p><p><strong>Results</strong></p><p>Use <a href="#PikaParser.find_match_at!-Union{Tuple{G}, Tuple{PikaParser.ParserState{G}, G, Int64}} where G"><code>find_match_at!</code></a> to extract matches from <a href="#PikaParser.ParserState"><code>ParserState</code></a>.</p><p>Pika parsing never really fails. Instead, in case when the grammar rule is not matched in the input, the expected rule match match is either not going to be found at the starting position with <a href="#PikaParser.find_match_at!-Union{Tuple{G}, Tuple{PikaParser.ParserState{G}, G, Int64}} where G"><code>find_match_at!</code></a>, or it will not span the whole input.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">parse(
    g,
    &quot;abcde123&quot;,
    (input, i, match) -&gt; isdigit(input[i]) ? match(:digit, i) : match(:letter, i),
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/parse.jl#L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.parse_lex-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}} where {G, T, I}" href="#PikaParser.parse_lex-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}} where {G, T, I}"><code>PikaParser.parse_lex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_lex(
    g::PikaParser.Grammar{G, T},
    input
) -&gt; PikaParser.ParserState
</code></pre><p>Use <a href="#PikaParser.lex-Union{Tuple{I}, Tuple{T}, Tuple{G}, Tuple{PikaParser.Grammar{G, T}, I}} where {G, T, I}"><code>lex</code></a> to greedily produce lexemes for a given grammar, and run the parsing atop the result.</p><p>While this will produce a different (much more sparse) parsing table and the resulting parse tree may be different from the &quot;full&quot; parse, having the lower levels of the parse tree efficiently pre-chewed vastly simplifies the overall parsing, thus saving a lot of time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/parse.jl#L232">source</a></section></article><h2 id="Traversing-and-folding-the-parse-tree"><a class="docs-heading-anchor" href="#Traversing-and-folding-the-parse-tree">Traversing and folding the parse tree</a><a id="Traversing-and-folding-the-parse-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Traversing-and-folding-the-parse-tree" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PikaParser.default_fold-Tuple{Any, Any, Any}" href="#PikaParser.default_fold-Tuple{Any, Any, Any}"><code>PikaParser.default_fold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_fold(m, p, subvals) -&gt; Expr
</code></pre><p>The default function used as <code>fold</code> argument in <a href="#PikaParser.traverse_match-Union{Tuple{I}, Tuple{G}, Tuple{PikaParser.ParserState{G, I}, Int64}} where {G, I}"><code>traverse_match</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/traverse.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.default_open-Tuple{Any, Any}" href="#PikaParser.default_open-Tuple{Any, Any}"><code>PikaParser.default_open</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_open(
    m,
    p
) -&gt; Base.Generator{_A, PikaParser.var&quot;#35#36&quot;} where _A
</code></pre><p>The default function used as <code>open</code> argument in <a href="#PikaParser.traverse_match-Union{Tuple{I}, Tuple{G}, Tuple{PikaParser.ParserState{G, I}, Int64}} where {G, I}"><code>traverse_match</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/traverse.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.find_match_at!-Union{Tuple{G}, Tuple{PikaParser.ParserState{G}, G, Int64}} where G" href="#PikaParser.find_match_at!-Union{Tuple{G}, Tuple{PikaParser.ParserState{G}, G, Int64}} where G"><code>PikaParser.find_match_at!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_match_at!(
    st::PikaParser.ParserState{G},
    rule,
    pos::Int64
) -&gt; Int64
</code></pre><p>Find the <a href="#PikaParser.Match"><code>Match</code></a> index in <a href="#PikaParser.ParserState"><code>ParserState</code></a> that matched <code>rule</code> at position <code>pos</code>, or <code>nothing</code> if there is no such match.</p><p>Zero-length matches may not be matched at all positions by default; this function creates the necessary matches in the tables in <code>st</code> in case they are missing. (That is the reason for the <code>!</code> label.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/traverse.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.traverse_match-Union{Tuple{I}, Tuple{G}, Tuple{PikaParser.ParserState{G, I}, Int64}} where {G, I}" href="#PikaParser.traverse_match-Union{Tuple{I}, Tuple{G}, Tuple{PikaParser.ParserState{G, I}, Int64}} where {G, I}"><code>PikaParser.traverse_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traverse_match(
    st::PikaParser.ParserState{G, I},
    mid::Int64;
    open,
    fold
) -&gt; Expr
</code></pre><p>Given a <a href="#PikaParser.Match"><code>Match</code></a> index in <a href="#PikaParser.ParserState"><code>ParserState</code></a> <code>st</code>, recusively depth-first traverse the match tree using functions <code>open</code> (called upon entering a submatch) and <code>fold</code> (called upon leaving the submatch).</p><p><code>open</code> is given a <a href="#PikaParser.UserMatch"><code>UserMatch</code></a> structure and a reference to the parser state. It should return a vector of boolean values that tell the traversal which submatches from the <a href="#PikaParser.UserMatch"><code>UserMatch</code></a> should be opened. That can be used to skip parsing of large uninteresting parts of the match tree, such as whitespace or comments. By default, it opens all submatches, thus the whole subtree is traversed.</p><p><code>fold</code> is given the <a href="#PikaParser.UserMatch"><code>UserMatch</code></a> structure and a reference to the parser state, and additionally a vector of folded values from the submatches. The values returned by <code>fold</code> invocations are collected and transferred to higher-level invocations of <code>fold</code>. In case <code>open</code> disabled the evaluation of a given submatch, <code>nothing</code> is used as the folded value for the submatch. The default <code>open</code> and <code>fold</code> (<a href="#PikaParser.default_open-Tuple{Any, Any}"><code>default_open</code></a>, <a href="#PikaParser.default_fold-Tuple{Any, Any, Any}"><code>default_fold</code></a>) just collect all submatch values and produce a Julia <code>Expr</code> AST structure where rule expansions are represented as function calls.</p><p>For producing the <a href="#PikaParser.UserMatch"><code>UserMatch</code></a> structures correctly, <code>traverse_match</code> additionally requires that the input vector (stored here in <code>ParserState</code>) has a compatible overload of the standard <code>Base.view</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/traverse.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.view_match-Tuple{PikaParser.ParserState, Int64}" href="#PikaParser.view_match-Tuple{PikaParser.ParserState, Int64}"><code>PikaParser.view_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_match(st::PikaParser.ParserState, mid::Int64) -&gt; Any
</code></pre><p>Get a view of input that corresponds to the match identified by given match ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/traverse.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.view_match-Tuple{PikaParser.ParserState, Union{PikaParser.Match, PikaParser.UserMatch}}" href="#PikaParser.view_match-Tuple{PikaParser.ParserState, Union{PikaParser.Match, PikaParser.UserMatch}}"><code>PikaParser.view_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_match(
    st::PikaParser.ParserState,
    match::Union{PikaParser.Match, PikaParser.UserMatch}
) -&gt; Any
</code></pre><p>Get a view of input that corresponds to the given <code>match</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/1f28460bd19d818fce03559029f5fe23566b0d8d/src/traverse.jl#L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../scheme/">« Example: Parsing Scheme</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 3 May 2023 19:13">Wednesday 3 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
