<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PikaParser.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PikaParser.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Data-types"><span>Data types</span></a></li><li><a class="tocitem" href="#Preparing-the-grammar"><span>Preparing the grammar</span></a></li><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#Traversing-and-folding-the-parse-tree"><span>Traversing and folding the parse tree</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Data-types"><a class="docs-heading-anchor" href="#Data-types">Data types</a><a id="Data-types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PikaParser.MatchResult" href="#PikaParser.MatchResult"><code>PikaParser.MatchResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A shortcut for possibly failed match result index (that points into <a href="#PikaParser.ParserState"><code>ParserState</code></a> field <code>matches</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Clause" href="#PikaParser.Clause"><code>PikaParser.Clause</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Clause{G}</code></pre><p>Abstract type for all clauses that match a grammar with rule labels of type <code>G</code>.</p><p>Currently implemented clauses:</p><ul><li><a href="#PikaParser.Satisfy"><code>Satisfy</code></a></li><li><a href="#PikaParser.TakeN"><code>TakeN</code></a></li><li><a href="#PikaParser.Token"><code>Token</code></a></li><li><a href="#PikaParser.Tokens"><code>Tokens</code></a></li><li><a href="#PikaParser.Epsilon"><code>Epsilon</code></a></li><li><a href="#PikaParser.Fail"><code>Fail</code></a></li><li><a href="#PikaParser.Seq"><code>Seq</code></a></li><li><a href="#PikaParser.First"><code>First</code></a></li><li><a href="#PikaParser.NotFollowedBy"><code>NotFollowedBy</code></a></li><li><a href="#PikaParser.FollowedBy"><code>FollowedBy</code></a></li><li><a href="#PikaParser.OneOrMore"><code>OneOrMore</code></a></li><li><a href="#PikaParser.ZeroOrMore"><code>ZeroOrMore</code></a></li></ul><p>Often it is better to use convenience functions for rule construction, such as <a href="#PikaParser.seq-Tuple"><code>seq</code></a> or <a href="#PikaParser.token-Tuple{Any}"><code>token</code></a>; see <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Epsilon" href="#PikaParser.Epsilon"><code>PikaParser.Epsilon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Epsilon{G} &lt;: PikaParser.Clause{G}</code></pre><p>An always-succeeding epsilon match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Fail" href="#PikaParser.Fail"><code>PikaParser.Fail</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Fail{G} &lt;: PikaParser.Clause{G}</code></pre><p>An always-failing match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.First" href="#PikaParser.First"><code>PikaParser.First</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct First{G} &lt;: PikaParser.Clause{G}</code></pre><p>Match the first possibility of several matches. Empty <code>First</code> is equivalent to unconditional failure.</p><p><strong>Fields</strong></p><ul><li><code>children::Vector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.FollowedBy" href="#PikaParser.FollowedBy"><code>PikaParser.FollowedBy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FollowedBy{G} &lt;: PikaParser.Clause{G}</code></pre><p>Zero-length match that succeeds if <code>follow</code> does match at the same position.</p><p><strong>Fields</strong></p><ul><li><code>follow::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Grammar" href="#PikaParser.Grammar"><code>PikaParser.Grammar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Grammar{G}</code></pre><p>A representation of the grammar prepared for parsing.</p><p><strong>Fields</strong></p><ul><li><p><code>names::Vector</code></p><p>Topologically sorted list of rule labels (non-terminals)</p></li><li><p><code>idx::Dict{G, Int64} where G</code></p><p>Mapping of rule labels to their indexes in <code>names</code></p></li><li><p><code>clauses::Vector{PikaParser.Clause{Int64}}</code></p><p>Clauses of the grammar converted to integer labels (and again sorted topologically)</p></li><li><p><code>can_match_epsilon::Vector{Bool}</code></p><p>Flags for the rules being able to match on empty string unconditionally</p></li><li><p><code>seed_clauses::Vector{Vector{Int64}}</code></p><p>Which clauses get seeded upon matching of a clause</p></li><li><p><code>terminals::Vector{Int64}</code></p><p>A summarized list of grammar terminals that are checked against each input letter</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Match" href="#PikaParser.Match"><code>PikaParser.Match</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Match</code></pre><p>Internal match representation.</p><p><strong>Fields</strong></p><ul><li><p><code>pos::Int64</code></p><p>Where the match started?</p></li><li><p><code>len::Int64</code></p><p>How long is the match?</p></li><li><p><code>option_idx::Int64</code></p><p>Which possibility did we match?</p></li><li><p><code>submatches::Vector{Int64}</code></p><p>Indexes to the vector of matches. This forms the edges in the match tree.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.MemoKey" href="#PikaParser.MemoKey"><code>PikaParser.MemoKey</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MemoKey</code></pre><p>Index into the memoization table.</p><p><strong>Fields</strong></p><ul><li><p><code>clause::Int64</code></p></li><li><p><code>start_pos::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.MemoTable" href="#PikaParser.MemoTable"><code>PikaParser.MemoTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SortedDict{PikaParser.MemoKey, Int64, Ord&lt;:Base.Order.Ordering} &lt;: AbstractDict{PikaParser.MemoKey, Int64}</code></pre><p>Pikaparser memoization table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.NotFollowedBy" href="#PikaParser.NotFollowedBy"><code>PikaParser.NotFollowedBy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotFollowedBy{G} &lt;: PikaParser.Clause{G}</code></pre><p>Zero-length match that succeeds if <code>reserved</code> does <em>not</em> match at the same position.</p><p><strong>Fields</strong></p><ul><li><code>reserved::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.OneOrMore" href="#PikaParser.OneOrMore"><code>PikaParser.OneOrMore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OneOrMore{G} &lt;: PikaParser.Clause{G}</code></pre><p>Greedily matches a sequence of matches, with at least 1 match.</p><p><strong>Fields</strong></p><ul><li><code>item::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.ParseResult" href="#PikaParser.ParseResult"><code>PikaParser.ParseResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ParseResult</code></pre><p>Representation of the parser output.</p><p><strong>Fields</strong></p><ul><li><p><code>memo::DataStructures.SortedDict{PikaParser.MemoKey, Int64}</code></p><p>Best matches of grammar rules for each position of the input</p></li><li><p><code>matches::Vector{PikaParser.Match}</code></p><p>Match tree (folded into a vector)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.ParserState" href="#PikaParser.ParserState"><code>PikaParser.ParserState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ParserState{G, I}</code></pre><p>Intermediate parsing state. The match tree is built in a vector of matches that grows during the matching, all match indexes point into this vector.</p><p><strong>Fields</strong></p><ul><li><p><code>grammar::PikaParser.Grammar</code></p></li><li><p><code>memo::DataStructures.SortedDict{PikaParser.MemoKey, Int64}</code></p></li><li><p><code>q::DataStructures.SortedSet{Int64}</code></p></li><li><p><code>matches::Vector{PikaParser.Match}</code></p></li><li><p><code>input::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Satisfy" href="#PikaParser.Satisfy"><code>PikaParser.Satisfy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Satisfy{G} &lt;: PikaParser.Clause{G}</code></pre><p>A single terminal. Matches a token from the input stream where the <code>match</code> function returns <code>true</code>.</p><p><strong>Fields</strong></p><ul><li><code>match::Function</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Seq" href="#PikaParser.Seq"><code>PikaParser.Seq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Seq{G} &lt;: PikaParser.Clause{G}</code></pre><p>Sequence of matches. Empty <code>Seq</code> is equivalent to an always-succeeding empty match, as in <a href="#PikaParser.Epsilon"><code>Epsilon</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>children::Vector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.TakeN" href="#PikaParser.TakeN"><code>PikaParser.TakeN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TakeN{G} &lt;: PikaParser.Clause{G}</code></pre><p>A single terminal. Given the input stream and a position in it, the <code>match</code> function returns the length of the match, or <code>nothing</code> if there&#39;s no match.</p><p><strong>Fields</strong></p><ul><li><code>match::Function</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Token" href="#PikaParser.Token"><code>PikaParser.Token</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Token{G} &lt;: PikaParser.Clause{G}</code></pre><p>A single token equal to <code>match</code>.</p><p><strong>Fields</strong></p><ul><li><code>token::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.Tokens" href="#PikaParser.Tokens"><code>PikaParser.Tokens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Tokens{G} &lt;: PikaParser.Clause{G}</code></pre><p>A series of tokens equal to <code>match</code>.</p><p><strong>Fields</strong></p><ul><li><code>tokens::Vector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.TraverseNode" href="#PikaParser.TraverseNode"><code>PikaParser.TraverseNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct TraverseNode{G}</code></pre><p>Part of intermediate tree traversing state.</p><p><strong>Fields</strong></p><ul><li><p><code>parent_idx::Int64</code></p></li><li><p><code>parent_sub_idx::Int64</code></p></li><li><p><code>rule::Any</code></p></li><li><p><code>match::PikaParser.UserMatch</code></p></li><li><p><code>open::Bool</code></p></li><li><p><code>subvals::Vector</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.UserMatch" href="#PikaParser.UserMatch"><code>PikaParser.UserMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UserMatch{G}</code></pre><p>User-facing representation of a <a href="#PikaParser.Match"><code>Match</code></a>.</p><p><strong>Fields</strong></p><ul><li><p><code>pos::Int64</code></p><p>Where the match started?</p></li><li><p><code>len::Int64</code></p><p>How long is the match?</p></li><li><p><code>submatches::Array{Tuple{Int64, G}, 1} where G</code></p><p>Indexes and rule labels of the matched submatches. This forms the edges in the match tree.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.ZeroOrMore" href="#PikaParser.ZeroOrMore"><code>PikaParser.ZeroOrMore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ZeroOrMore{G} &lt;: PikaParser.Clause{G}</code></pre><p>Greedily matches a sequence of matches that can be empty.</p><p><strong>Fields</strong></p><ul><li><code>item::Any</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/structs.jl#L155">source</a></section></article><h2 id="Preparing-the-grammar"><a class="docs-heading-anchor" href="#Preparing-the-grammar">Preparing the grammar</a><a id="Preparing-the-grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Preparing-the-grammar" title="Permalink"></a></h2><h3 id="Specifying-rules"><a class="docs-heading-anchor" href="#Specifying-rules">Specifying rules</a><a id="Specifying-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-rules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PikaParser.epsilon" href="#PikaParser.epsilon"><code>PikaParser.epsilon</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">epsilon :: Clause</code></pre><p>An <a href="#PikaParser.Epsilon"><code>Epsilon</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">maybe_letter_a = first(token(&#39;a&#39;), epsilon)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.fail" href="#PikaParser.fail"><code>PikaParser.fail</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">fail :: Clause</code></pre><p>A <a href="#PikaParser.Fail"><code>Fail</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p>Useful for avoiding rule specification when matching terminals using the <code>fast_match</code> parameter of <a href="#PikaParser.parse"><code>parse</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">seq(:this, :that, fail)  # this rule is effectively disabled</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L58-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.first-Tuple" href="#PikaParser.first-Tuple"><code>PikaParser.first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">first(args...) -&gt; PikaParser.First
</code></pre><p>Build a <a href="#PikaParser.First"><code>First</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">first(:something, :fallback, :fallback2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G" href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>PikaParser.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten(rules::Dict{G}) -&gt; Dict
flatten(rules::Dict{G}, childlabel::Function) -&gt; Dict
</code></pre><p>Convert a possibly nested and weakly typed <code>rules</code> into a correctly typed and unnested ruleset, usable in <a href="#PikaParser.make_grammar-Union{Tuple{G}, Tuple{AbstractVector{G}, Dict{G, PikaParser.Clause{G}}}} where G"><code>make_grammar</code></a>. This allows use of convenience rule building functions:</p><ul><li><a href="#PikaParser.satisfy-Tuple{Function}"><code>satisfy</code></a></li><li><a href="#PikaParser.take_n-Tuple{Function}"><code>take_n</code></a></li><li><a href="#PikaParser.token-Tuple{Any}"><code>token</code></a></li><li><a href="#PikaParser.tokens-Tuple{Vector}"><code>tokens</code></a></li><li><a href="#PikaParser.epsilon"><code>epsilon</code></a> (not a function!)</li><li><a href="#PikaParser.fail"><code>fail</code></a> (not a function!)</li><li><a href="#PikaParser.seq-Tuple"><code>seq</code></a></li><li><a href="#PikaParser.first-Tuple"><code>first</code></a></li><li><a href="#PikaParser.not_followed_by-Tuple{Any}"><code>not_followed_by</code></a></li><li><a href="#PikaParser.followed_by-Tuple{Any}"><code>followed_by</code></a></li><li><a href="#PikaParser.one_or_more-Tuple{Any}"><code>one_or_more</code></a></li><li><a href="#PikaParser.zero_or_more-Tuple{Any}"><code>zero_or_more</code></a></li><li><a href="#PikaParser.precedence_cascade-Tuple{Function, Vararg{Any}}"><code>precedence_cascade</code></a> (not backed by an actual <a href="#PikaParser.Clause"><code>Clause</code></a>!)</li></ul><p>Anonymous nested rules are assigned names that are constructed by <code>childlabel</code> function (gets the original G and and integer with position integer). By default, <code>childlabel</code> concatenats the parent rule name, hyphen, and the position number to form a <code>Symbol</code> (i.e., the default works only in cases when the rules are labeled by Symbols, and you need to provide your own implementation for other grammars labeled e.g. by integers or strings).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.followed_by-Tuple{Any}" href="#PikaParser.followed_by-Tuple{Any}"><code>PikaParser.followed_by</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">followed_by(x) -&gt; PikaParser.FollowedBy
</code></pre><p>Build a <a href="#PikaParser.FollowedBy"><code>FollowedBy</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">seq(:digits, followed_by(:whitespace))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.not_followed_by-Tuple{Any}" href="#PikaParser.not_followed_by-Tuple{Any}"><code>PikaParser.not_followed_by</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">not_followed_by(x) -&gt; PikaParser.NotFollowedBy
</code></pre><p>Build a <a href="#PikaParser.NotFollowedBy"><code>NotFollowedBy</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">seq(not_followed_by(tokens(collect(&quot;reservedWord&quot;))), :identifier)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.one_or_more-Tuple{Any}" href="#PikaParser.one_or_more-Tuple{Any}"><code>PikaParser.one_or_more</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">one_or_more(x) -&gt; PikaParser.OneOrMore
</code></pre><p>Build a <a href="#PikaParser.OneOrMore"><code>OneOrMore</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">one_or_more(satisfy(isspace))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.precedence_cascade-Tuple{Function, Vararg{Any}}" href="#PikaParser.precedence_cascade-Tuple{Function, Vararg{Any}}"><code>PikaParser.precedence_cascade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precedence_cascade(label::Function, levels...) -&gt; Vector
</code></pre><p>Convert a list of rules of increasing associativity to a typical precedence-handling &quot;failthrough&quot; construction. The result must be post-processed by <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p>Each of the rules is abstracted by &quot;same-associativity&quot; and &quot;higher-associativity&quot; rules (i.e., it is a binary function), which is used to correctly link the rules within the precedence group. The first rule is of the lowest precedence. All rules except the last automatically fallback to the next rule. The higher-precedence parameter of the last rule is the label of the first rule.</p><p><code>label</code> is a function that generates the label for given <code>n</code>-th level of the grammar.</p><p>Use <a href="#PikaParser.@precedences-Tuple{Any, Symbol, Symbol, Any}"><code>@precedences</code></a> for a less verbose construction.</p><p>Returns a vector of labeled rules; that must usually be interpolated into the ruleset.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Dict(
    precedence_cascade(
        n -&gt; Symbol(:exprlevel, n),
        (same, next) -&gt; :expr =&gt; first(
            :plus =&gt; seq(same, token(&#39;+&#39;), next),
            :minus =&gt; seq(same, token(&#39;-&#39;), next),
        ),
        (same, next) -&gt; :times =&gt; seq(same, token(&#39;*&#39;), next), # left associative
        (same, next) -&gt; :power =&gt; seq(next, token(&#39;^&#39;), same), # right associative
        (_, restart) -&gt; first(
            :parens =&gt; seq(token(&#39;(&#39;), restart, token(&#39;)&#39;)),
            :digits =&gt; one_or_more(satisfy(isdigit)),
        ),
    )...,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.satisfy-Tuple{Function}" href="#PikaParser.satisfy-Tuple{Function}"><code>PikaParser.satisfy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">satisfy(f::Function) -&gt; PikaParser.Satisfy{Any}
</code></pre><p>Build a <a href="#PikaParser.Satisfy"><code>Satisfy</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">satisfy(isdigit)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.seq-Tuple" href="#PikaParser.seq-Tuple"><code>PikaParser.seq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seq(args...) -&gt; PikaParser.Seq
</code></pre><p>Build a <a href="#PikaParser.Seq"><code>Seq</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">digit_in_parents = seq(token(&#39;(&#39;), :digit, token(&#39;)&#39;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.take_n-Tuple{Function}" href="#PikaParser.take_n-Tuple{Function}"><code>PikaParser.take_n</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">take_n(f::Function) -&gt; PikaParser.TakeN{Any}
</code></pre><p>Build a <a href="#PikaParser.TakeN"><code>TakeN</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs"># rule to match a pair of equal tokens
take_n(m -&gt; m[1] == m[2] ? 2 : nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.token-Tuple{Any}" href="#PikaParser.token-Tuple{Any}"><code>PikaParser.token</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">token(x) -&gt; PikaParser.Token{Any}
</code></pre><p>Build a <a href="#PikaParser.Token"><code>Token</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">token(&#39;a&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.tokens-Tuple{Vector}" href="#PikaParser.tokens-Tuple{Vector}"><code>PikaParser.tokens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tokens(xs::Vector) -&gt; PikaParser.Tokens{Any}
</code></pre><p>Build a <a href="#PikaParser.Tokens"><code>Tokens</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">tokens(collect(&quot;keyword&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.zero_or_more-Tuple{Any}" href="#PikaParser.zero_or_more-Tuple{Any}"><code>PikaParser.zero_or_more</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_or_more(x) -&gt; PikaParser.ZeroOrMore
</code></pre><p>Build a <a href="#PikaParser.ZeroOrMore"><code>ZeroOrMore</code></a> clause. Translate to strongly typed grammar with <a href="#PikaParser.flatten-Union{Tuple{Dict{G}}, Tuple{G}, Tuple{Dict{G}, Function}} where G"><code>flatten</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">seq(:quote, zero_or_more(:quote_contents), :quote)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.@precedences-Tuple{Any, Symbol, Symbol, Any}" href="#PikaParser.@precedences-Tuple{Any, Symbol, Symbol, Any}"><code>PikaParser.@precedences</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@precedences labeller same::Symbol next::Symbol rules</code></pre><p>A shortcut macro for <a href="#PikaParser.precedence_cascade-Tuple{Function, Vararg{Any}}"><code>precedence_cascade</code></a>. Automatically adds lambda heads with fixed argument names, and splats itself with <code>...</code> into the surrounding environment.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Dict(
    @precedences (n-&gt;Symbol(:exprlevel, n)) same next begin
        :expr =&gt; seq(same, token(&#39;+&#39;), next)
        seq(same, token(&#39;*&#39;), next)
        first(
            token(&#39;x&#39;),
            seq(token(&#39;(&#39;), next, token(&#39;)&#39;))
        )
    end
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/frontend.jl#L188-L207">source</a></section></article><h3 id="Converting-to-a-Grammar"><a class="docs-heading-anchor" href="#Converting-to-a-Grammar">Converting to a <code>Grammar</code></a><a id="Converting-to-a-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-to-a-Grammar" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PikaParser.make_grammar-Union{Tuple{G}, Tuple{AbstractVector{G}, Dict{G, PikaParser.Clause{G}}}} where G" href="#PikaParser.make_grammar-Union{Tuple{G}, Tuple{AbstractVector{G}, Dict{G, PikaParser.Clause{G}}}} where G"><code>PikaParser.make_grammar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_grammar(starts::AbstractArray{G, 1}, rules_dict::Dict{G, PikaParser.Clause{G}}) -&gt; PikaParser.Grammar
</code></pre><p>Produce a <a href="#PikaParser.Grammar"><code>Grammar</code></a> with rules of type <code>G</code> that can be used to <a href="#PikaParser.parse"><code>parse</code></a> inputs.</p><p><code>starts</code> should collect top-level rules (these will be put at the top of the topological order of the parsing).</p><p><code>rules_dict</code> is a dictionary of grammar <a href="#PikaParser.Clause"><code>Clause</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/grammar.jl#L2">source</a></section></article><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PikaParser.parse" href="#PikaParser.parse"><code>PikaParser.parse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse(grammar::PikaParser.Grammar, input::AbstractVector) -&gt; PikaParser.ParseResult
parse(grammar::PikaParser.Grammar, input::AbstractVector, fast_match) -&gt; PikaParser.ParseResult
</code></pre><p>Take a <a href="#PikaParser.Grammar"><code>Grammar</code></a> and an indexable input sequence, and produce a <a href="#PikaParser.ParseResult"><code>ParseResult</code></a> that describes all matched grammar productions.</p><p><strong>Fast terminal matching</strong></p><p>If <code>fast_match</code> is specified, the function does not match terminals using the associated grammar rules, but with a <code>fast_match</code> function that reports the matched terminals via a callback. The function is called exactly once for each position in <code>input</code> in reverse order (i.e., the indexes will follow <code>reverse(1:length(input))</code>, which can be utilized by the application for optimization).  The call parameters consist of the input vector, position in the input vector, and a &quot;report&quot; function used to send back a clause ID (of same type as <code>G</code> in <code>typeof(grammar)</code>) and the length of the terminal matches that can found at that position. Calls to the reporting function can be repeated if more terminal types match. Terminals not reported by the calls to <code>fast_match</code> will not be matched.</p><p>For complicated grammars, this may be much faster than having the parser to try matching all terminal types at each position.</p><p><strong>Results</strong></p><p>Use <a href="#PikaParser.find_first_parse_at-Union{Tuple{G}, Tuple{PikaParser.Grammar{G}, PikaParser.ParseResult, Int64}} where G"><code>find_first_parse_at</code></a> or <a href="#PikaParser.find_match_at-Union{Tuple{G}, Tuple{PikaParser.Grammar{G}, PikaParser.ParseResult, G, Int64}} where G"><code>find_match_at</code></a> to extract matches from <a href="#PikaParser.ParseResult"><code>ParseResult</code></a>.</p><p>Pika parsing never really fails. Instead, in case when the grammar rule is not matched in the input, the expected rule match match is either not going to be found at the starting position with <a href="#PikaParser.find_match_at-Union{Tuple{G}, Tuple{PikaParser.Grammar{G}, PikaParser.ParseResult, G, Int64}} where G"><code>find_match_at</code></a>, or it will not span the whole input.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">parse(
    g,
    collect(&quot;abcde123&quot;),
    (input, i, match) -&gt; isdigit(input[i]) ? match(:digit, 1) : match(:letter, 1),
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/parse.jl#L38">source</a></section></article><h2 id="Traversing-and-folding-the-parse-tree"><a class="docs-heading-anchor" href="#Traversing-and-folding-the-parse-tree">Traversing and folding the parse tree</a><a id="Traversing-and-folding-the-parse-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Traversing-and-folding-the-parse-tree" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PikaParser.find_first_parse_at-Union{Tuple{G}, Tuple{PikaParser.Grammar{G}, PikaParser.ParseResult, Int64}} where G" href="#PikaParser.find_first_parse_at-Union{Tuple{G}, Tuple{PikaParser.Grammar{G}, PikaParser.ParseResult, Int64}} where G"><code>PikaParser.find_first_parse_at</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_first_parse_at(grammar::PikaParser.Grammar{G}, parse::PikaParser.ParseResult, pos::Int64) -&gt; Any
</code></pre><p>Find any possible match of anything starting at input position <code>pos</code>. Preferentially returns the parses that are topologically higher.</p><p>If found, returns the <a href="#PikaParser.Match"><code>Match</code></a> index in <a href="#PikaParser.ParseResult"><code>ParseResult</code></a>, and the corresponding grammar production rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/traverse.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.find_match_at-Union{Tuple{G}, Tuple{PikaParser.Grammar{G}, PikaParser.ParseResult, G, Int64}} where G" href="#PikaParser.find_match_at-Union{Tuple{G}, Tuple{PikaParser.Grammar{G}, PikaParser.ParseResult, G, Int64}} where G"><code>PikaParser.find_match_at</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_match_at(grammar::PikaParser.Grammar{G}, parse::PikaParser.ParseResult, rule, pos::Int64) -&gt; Union{Nothing, Int64}
</code></pre><p>Find the <a href="#PikaParser.Match"><code>Match</code></a> index in <a href="#PikaParser.ParseResult"><code>ParseResult</code></a> that matched <code>rule</code> at position <code>pos</code>, or <code>nothing</code> if there is no such match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/traverse.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PikaParser.traverse_match-Union{Tuple{G}, Tuple{PikaParser.Grammar{G}, PikaParser.ParseResult, Int64, G}} where G" href="#PikaParser.traverse_match-Union{Tuple{G}, Tuple{PikaParser.Grammar{G}, PikaParser.ParseResult, Int64, G}} where G"><code>PikaParser.traverse_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traverse_match(grammar::PikaParser.Grammar{G}, parse::PikaParser.ParseResult, mid::Int64, rule; open, fold) -&gt; Expr
</code></pre><p>Given a <a href="#PikaParser.Match"><code>Match</code></a> index and the grammar <code>rule</code> matched at that index, recusively depth-first traverse the match tree using functions <code>open</code> (called upon entering a submatch) and <code>fold</code> (called upon leaving the submatch).</p><p><code>open</code> is given the current grammar rule and the <a href="#PikaParser.UserMatch"><code>UserMatch</code></a>. It should return a vector of boolean values that tell the traversal which submatches from the <a href="#PikaParser.UserMatch"><code>UserMatch</code></a> should be opened. That can be used to skip parsing of large uninteresting parts of the match tree, such as whitespace or comments. By default, it opens the whole subtree.</p><p><code>fold</code> is given the same current grammar rule and the <a href="#PikaParser.UserMatch"><code>UserMatch</code></a>, and additionally a vector of folded values from the submatches. The values returned by <code>fold</code> invocations are collected and transferred to higher-level invocations of <code>fold</code>. In case <code>open</code> disabled the evaluation of a given submatch, <code>nothing</code> is used as the folded value for the submatch. By default, <code>fold</code> just collects all submatch values and produces a Julia <code>Expr</code> AST structure where rule expansions are represented as function calls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/6a56e0474706ced36853e35ebe957bb9a759c614/src/traverse.jl#L37">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« README</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 27 June 2022 14:52">Monday 27 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
