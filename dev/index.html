<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>README · PikaParser.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PikaParser.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>README</a></li><li><a class="tocitem" href="json/">Example: Parsing JSON</a></li><li><a class="tocitem" href="scheme/">Example: Parsing Scheme</a></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>README</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>README</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PikaParser.jl"><a class="docs-heading-anchor" href="#PikaParser.jl">PikaParser.jl</a><a id="PikaParser.jl-1"></a><a class="docs-heading-anchor-permalink" href="#PikaParser.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PikaParser.PikaParser" href="#PikaParser.PikaParser"><code>PikaParser.PikaParser</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>PikaParser.jl</strong></p><p>A simple straightforward implementation of PikaParser in pure Julia, following the specification by Luke A. D. Hutchison (see https://github.com/lukehutch/pikaparser).</p><p>Pika parsers are pretty fast, they are easy to specify, carry the ability to unambiguously match all PEG grammars including the left-recursive ones, and provide great mechanisms for parsing error recovery.</p><p>The code is new, <strong>feedback is welcome</strong>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import PikaParser as P</code></pre><p><strong>Building a grammar</strong></p><p>All grammar clauses are subtype of a <code>Clause</code>. The types are indexed by the labels for your grammar rules – Julia symbols are a natural choice, but you are free to use integers, strings, or anything else.</p><pre><code class="language-julia hljs">rules = Dict(
    # match a sequence of characters that satisfies `isdigit`
    :digits =&gt; P.some(:digit =&gt; P.satisfy(isdigit)),

    # expression in parentheses
    :parens =&gt; P.seq(
        P.token(&#39;(&#39;),
        # you can name the rules in nested contexts
        :expr =&gt; P.first(:plusexpr, :minusexpr, :digits, :parens),
        P.token(&#39;)&#39;),
    ),

    # some random operators
    :plusexpr =&gt; P.seq(:expr, P.token(&#39;+&#39;), :expr),
    :minusexpr =&gt; P.seq(:expr, P.token(&#39;-&#39;), :expr),
)

g = P.make_grammar(
    [:expr], # the top-level rule
    P.flatten(rules),
)</code></pre><p>The grammar is now prepared for parsing.</p><p><strong>Parsing text</strong></p><p>Pika parsers require frequent indexing of the input, Strings thus need to be converted to character vectors to be usable as parser input. (To improve performance, it is advisable to lex your input into a vector of more complex tokens.)</p><pre><code class="language-julia hljs">input = collect(&quot;12-(34+567-8)&quot;)
p = P.parse(g, input)</code></pre><p>You can find if an expression was matched at a certain position:</p><pre><code class="language-julia hljs">P.find_match_at!(p, :expr, 1)</code></pre><p>...which returns an index in the match table (if found), such as <code>45</code>.</p><p>You can have a look at the match. <code>p.matches[45]</code> should return:</p><pre><code class="language-julia hljs">PikaParser.Match(10, 1, 13, 2, [44])</code></pre><p>where <code>10</code> is the renumbered rule ID for <code>:expr</code>, <code>1</code> is the starting position in the input, <code>13</code> is the length of the match (here, that is the whole input); <code>2</code> is the option index (in this case, it points to <code>:expr</code> option 2, which is <code>:minusexpr</code>), and 44 is the submatch of <code>:minusexpr</code>.</p><p><strong>Recovering parsed ASTs</strong></p><p>You can use <code>traverse_match</code> to recursively walk the parse trees, to produce ASTs, and translate, interpret or evaluate the expressions:</p><pre><code class="language-julia hljs">P.traverse_match(p, P.find_match_at!(p, :expr, 1))</code></pre><p>By default, this runs through the whole match tree and transcodes the matches to Julia <code>Expr</code> AST. In this case, if you pipe the output through JuliaFormatter, you will get something like:</p><pre><code class="language-julia hljs">expr(
    minusexpr(
        expr(digits(digit(&#39;1&#39;), digit(&#39;2&#39;))),
        var&quot;minusexpr-2&quot;(&#39;-&#39;),
        expr(
            parens(
                var&quot;parens-1&quot;(&#39;(&#39;),
                expr(
                    plusexpr(
                        expr(digits(digit(&#39;3&#39;), digit(&#39;4&#39;))),
                        var&quot;plusexpr-2&quot;(&#39;+&#39;),
                        expr(
                            minusexpr(
                                expr(digits(digit(&#39;5&#39;), digit(&#39;6&#39;), digit(&#39;7&#39;))),
                                var&quot;minusexpr-2&quot;(&#39;-&#39;),
                                expr(digits(digit(&#39;8&#39;))),
                            ),
                        ),
                    ),
                ),
                var&quot;parens-3&quot;(&#39;)&#39;),
            ),
        ),
    ),
)</code></pre><p>It is straightforward to specify your own method of evaluating the parses by supplying the matchtree opening and folding functions. For example, you can evaluate the expression as follows:</p><pre><code class="language-julia hljs">P.traverse_match(p, P.find_match_at!(p, :expr, 1),
    fold = (m, p, subvals) -&gt;
        m.rule == :digits ? parse(Int, String(m.view)) :
        m.rule == :expr ? subvals[1] :
        m.rule == :parens ? subvals[2] :
        m.rule == :plusexpr ? subvals[1] + subvals[3] :
        m.rule == :minusexpr ? subvals[1] - subvals[3] : nothing,
)</code></pre><p>You should get the expectable result (<code>-581</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LCSB-BioCore/PikaParser.jl/blob/4eb24f12382c7cbf61d30f01e5d57d5c66b0aaca/src/PikaParser.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="json/">Example: Parsing JSON »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 4 July 2022 11:31">Monday 4 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
